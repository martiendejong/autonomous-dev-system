<#
.SYNOPSIS
    Scans codebase for TODO/FIXME/HACK comments and optionally creates GitHub issues.

.DESCRIPTION
    Finds all TODO, FIXME, HACK, and NOTE comments in code.
    Can create GitHub issues automatically for tracking.

    Supported patterns:
    - TODO: description
    - FIXME: description
    - HACK: description
    - NOTE: description
    - BUG: description

.PARAMETER Path
    Path to scan (file or directory)

.PARAMETER Recursive
    Scan subdirectories recursively

.PARAMETER CreateIssues
    Create GitHub issues for TODOs

.PARAMETER Repository
    GitHub repository (owner/repo) for issue creation

.PARAMETER Label
    Labels to add to created issues (comma-separated)

.EXAMPLE
    .\track-todos.ps1 -Path "C:\Projects\client-manager" -Recursive
    .\track-todos.ps1 -Path "src" -CreateIssues -Repository "martiendejong/client-manager"
    .\track-todos.ps1 -Path "." -Recursive -Label "technical-debt,todo"
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$Path,

    [switch]$Recursive,
    [switch]$CreateIssues,
    [string]$Repository,
    [string]$Label = "technical-debt"
)
# AUTO-USAGE TRACKING
$toolName = $MyInvocation.MyCommand.Name -replace '\.ps1$', ''
. "$PSScriptRoot\_usage-logger.ps1" -ToolName $toolName -Action "execute" -Metadata @{ Parameters = ($PSBoundParameters.Keys -join ',') } -ErrorAction SilentlyContinue

$TodoPatterns = @{
    "TODO" = "TODO:?\s*(.+)"
    "FIXME" = "FIXME:?\s*(.+)"
    "HACK" = "HACK:?\s*(.+)"
    "NOTE" = "NOTE:?\s*(.+)"
    "BUG" = "BUG:?\s*(.+)"
}

# File patterns to exclude
$ExcludePatterns = @(
    '*.md',
    '*.txt',
    '*.log',
    'package-lock.json',
    'yarn.lock',
    '*.min.js',
    '*.map',
    'node_modules',
    '.git',
    'dist',
    'build',
    'bin',
    'obj',
    '.vs'
)

function Test-ShouldExclude {
    param([string]$FilePath)

    foreach ($pattern in $ExcludePatterns) {
        if ($FilePath -like "*$pattern*") {
            return $true
        }
    }
    return $false
}

function Find-TODOs {
    param([string]$FilePath)

    if (Test-ShouldExclude -FilePath $FilePath) {
        return @()
    }

    if (-not (Test-Path $FilePath)) {
        return @()
    }

    try {
        $content = Get-Content $FilePath -Raw -ErrorAction Stop
    } catch {
        return @()
    }

    $todos = @()
    $lines = $content -split "`n"

    for ($i = 0; $i -lt $lines.Count; $i++) {
        $line = $lines[$i]

        foreach ($type in $TodoPatterns.Keys) {
            $pattern = $TodoPatterns[$type]

            if ($line -match $pattern) {
                $description = $matches[1].Trim()

                # Remove common comment markers
                $description = $description -replace '^[\*\/\#\-\s]+', ''
                $description = $description -replace '[\*\/]+$', ''
                $description = $description.Trim()

                $todos += @{
                    "Type" = $type
                    "Description" = $description
                    "File" = $FilePath
                    "Line" = $i + 1
                    "Context" = $line.Trim()
                }
            }
        }
    }

    return $todos
}

function Scan-Directory {
    param([string]$DirPath, [bool]$IsRecursive)

    $allTODOs = @()

    $files = if ($IsRecursive) {
        Get-ChildItem -Path $DirPath -File -Recurse -ErrorAction SilentlyContinue
    } else {
        Get-ChildItem -Path $DirPath -File -ErrorAction SilentlyContinue
    }

    $totalFiles = $files.Count
    $scannedFiles = 0

    Write-Host "Scanning $totalFiles files..." -ForegroundColor Cyan
    Write-Host ""

    foreach ($file in $files) {
        $scannedFiles++

        if ($scannedFiles % 100 -eq 0) {
            Write-Host "  Scanned $scannedFiles / $totalFiles files..." -ForegroundColor DarkGray
        }

        $todos = Find-TODOs -FilePath $file.FullName
        $allTODOs += $todos
    }

    return $allTODOs
}

function Create-GitHubIssue {
    param([hashtable]$TODO, [string]$Repo, [string]$Labels)

    $relativePath = $TODO.File -replace [regex]::Escape((Get-Location).Path), "."

    $title = "[$($TODO.Type)] $($TODO.Description)"
    if ($title.Length -gt 100) {
        $title = $title.Substring(0, 97) + "..."
    }

    $body = @"
Found in code:

File: ``$relativePath:$($TODO.Line)``

``````
$($TODO.Context)
``````

Description: $($TODO.Description)

---
Auto-generated by track-todos.ps1
"@

    try {
        $labelsParam = if ($Labels) { "--label `"$Labels`"" } else { "" }

        $issueUrl = gh issue create `
            --repo $Repo `
            --title $title `
            --body $body `
            $labelsParam 2>&1

        if ($LASTEXITCODE -eq 0) {
            return $issueUrl
        } else {
            Write-Host "  Failed: $issueUrl" -ForegroundColor Red
            return $null
        }

    } catch {
        Write-Host "  Error creating issue: $_" -ForegroundColor Red
        return $null
    }
}

# Main execution
Write-Host ""
Write-Host "=== TODO Tracker ===" -ForegroundColor Cyan
Write-Host ""

if (-not (Test-Path $Path)) {
    Write-Host "ERROR: Path not found: $Path" -ForegroundColor Red
    exit 1
}

$isDirectory = (Get-Item $Path) -is [System.IO.DirectoryInfo]

$todos = if ($isDirectory) {
    Scan-Directory -DirPath $Path -IsRecursive:$Recursive
} else {
    Find-TODOs -FilePath $Path
}

# Display results
Write-Host ""
Write-Host "=== Scan Results ===" -ForegroundColor Cyan
Write-Host ""

if ($todos.Count -eq 0) {
    Write-Host "No TODOs found!" -ForegroundColor Green
    Write-Host ""
    exit 0
}

Write-Host "Found $($todos.Count) TODO items:" -ForegroundColor Yellow
Write-Host ""

# Group by type
$byType = $todos | Group-Object -Property Type

foreach ($group in $byType | Sort-Object Name) {
    Write-Host "$($group.Name): $($group.Count)" -ForegroundColor White
}

Write-Host ""

# Group by file
$byFile = $todos | Group-Object -Property File | Sort-Object Count -Descending

Write-Host "=== Top Files with TODOs ===" -ForegroundColor Cyan
Write-Host ""

foreach ($group in $byFile | Select-Object -First 10) {
    $relativePath = $group.Name -replace [regex]::Escape((Get-Location).Path), "."
    Write-Host ("  {0,-60} {1} items" -f $relativePath, $group.Count) -ForegroundColor DarkGray
}

Write-Host ""

# Show all TODOs
Write-Host "=== All TODOs ===" -ForegroundColor Cyan
Write-Host ""

foreach ($todo in $todos) {
    $relativePath = $todo.File -replace [regex]::Escape((Get-Location).Path), "."

    $color = switch ($todo.Type) {
        "TODO" { "Yellow" }
        "FIXME" { "Red" }
        "HACK" { "Magenta" }
        "BUG" { "Red" }
        default { "White" }
    }

    Write-Host "[$($todo.Type)] $relativePath:$($todo.Line)" -ForegroundColor $color
    Write-Host "  $($todo.Description)" -ForegroundColor DarkGray
    Write-Host ""
}

# Create GitHub issues if requested
if ($CreateIssues) {
    if (-not $Repository) {
        Write-Host "ERROR: -Repository required for issue creation" -ForegroundColor Red
        Write-Host "Usage: -Repository 'owner/repo'" -ForegroundColor Yellow
        exit 1
    }

    Write-Host "=== Creating GitHub Issues ===" -ForegroundColor Cyan
    Write-Host ""

    $created = 0
    foreach ($todo in $todos) {
        Write-Host "Creating issue for: $($todo.Description.Substring(0, [Math]::Min(50, $todo.Description.Length)))..." -ForegroundColor DarkGray

        $issueUrl = Create-GitHubIssue -TODO $todo -Repo $Repository -Labels $Label

        if ($issueUrl) {
            Write-Host "  Created: $issueUrl" -ForegroundColor Green
            $created++
        }

        # Rate limiting
        Start-Sleep -Milliseconds 500
    }

    Write-Host ""
    Write-Host "Created $created issues" -ForegroundColor Green
    Write-Host ""
}

Write-Host "=== Scan Complete ===" -ForegroundColor Green
Write-Host ""

exit 0
